#!/usr/bin/env bash
# game
# Generate a dmenu for games on various platforms with associated cover images
# and launch them based on custom shell scripts tailored for their needs.

shopt -s nullglob
readonly progn=game
readonly optsfile="${XDG_CONFIG_HOME:-$HOME/local/cfg}"/dmenu/dmenucolors
readonly datadir="${XDG_DATA_HOME:-$HOME/local/share}"
readonly prefix="$datadir"/game
readonly bindir="$prefix"/bin
readonly coverdir="$prefix"/covers

# Main globals used throughout the code, unfortunately.
declare -A titles
declare -A covers


puts() {
    printf -- "$1\n" "${@:2}"
}

has() {
    hash "$1" 2> /dev/null
}

err() {
    local msg

    puts "$progn: $1" "{@:2}" >&2
    if has notify-send; then
        msg="$(puts "$@")"
        notify-send -u critical -- "$progn" "$msg"
    fi
}

title_in() {
    local title

    while read -r title; do
        if [[ "$title" =~ '# Title: '?(.*) ]]; then
            puts '%s' "${BASH_REMATCH[1]}"
            break
        fi
    done
}

generate_entry_data() {
    #global bindir coverdir
    local file filename title cover

    for file in "$bindir"/*; do
        if [[ -e "$file" ]]; then
            title="$(title_in < "$file")"
        fi

        filename="${file##*/}"

        # Use the filename if no title could be found.
        if [[ -z "$title" ]]; then
            title="$filename"
        fi

        # If a matching cover image isn't found use a placeholder instead.
        if [[ -e "$coverdir"/"$filename" ]]; then
            cover="$coverdir"/"$filename"
        else
            cover="$coverdir"/placeholder
        fi

        puts '%s' "$title"
        puts '%s' "$file"
        puts '%s' "$cover"
    done
}

create_menu() {
    #global titles covers
    local key

    for key in "${!titles[@]}"; do
        puts 'IMG:%s\t%s' "${covers[$key]}" "$key"
    done
}

get_user_picks() {
    #global opts
    create_menu | sort | dmenu "${opts[@]}"
}

launch() {
    local err
    local entry="$1"

    if ! err="$(command -- "$entry")"; then
        err '%s' "${err:-$entry}"
    fi
}

populate_arrays() {
    #global titles covers

    # Parse the list into two arrays.  We keep a consistent key so we can access
    # the correct corresonding information for both lookups.
    while {
        read -r title
        read -r entry
        read -r cover
    } do
        titles["$title"]="$entry"
        covers["$title"]="$cover"
    done
}

process_results() {
    #global titles
    local pick entry

    while read -r pick; do
        if [[ -n "${titles[$pick]}" ]]; then
            entry="${titles[$pick]}"
        else
            err '%s: Cannot find associated launcher.' "$pick"
            exit 1
        fi

        launch "$entry" &
    done
}

get_options() {
    if [[ -e "$optsfile" ]]; then
        # Parse optsfile
        read -r font < "${XDG_CONFIG_HOME:-$HOME/.config}"/dmenu/font
        if [[ ! "$font" ]]; then
            err "No font found in ${XDG_CONFIG_HOME:-$HOME/.config}/dmenu/font,                 using default."
        fi
        source "${XDG_CONFIG_HOME:-$HOME/.config}"/dmenu/dmenucolors
    else
        err "No configuration found for dmenu in ${XDG_CONFIG_HOME:-$HOME/.config}/dmenu/dmenucolors"
    fi
}

# Main loop
get_options && opts+=( -p "Play" )

mkdir -p "$datadir" "$bindir" "$coverdir"

populate_arrays < <(generate_entry_data)

results="$(get_user_picks)"

if [[ -n "$results" ]]; then
    process_results <<< "$results"
fi
